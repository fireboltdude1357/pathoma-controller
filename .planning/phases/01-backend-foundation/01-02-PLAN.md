---
phase: 01-backend-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - app/layout.tsx
  - app/providers.tsx
  - middleware.ts
  - convex/users.ts
  - convex/commands.ts
  - convex/auth.config.ts
  - .env.local
autonomous: false
user_setup:
  - service: clerk
    why: "Clerk-Convex JWT integration"
    dashboard_config:
      - task: "Add Convex JWT template"
        location: "Clerk Dashboard -> JWT Templates -> New Template -> Convex"
        details: "Use the Convex template, copy the Issuer URL"
      - task: "Get Issuer URL for Convex"
        location: "Clerk Dashboard -> JWT Templates -> Convex template -> Issuer"

must_haves:
  truths:
    - "User can authenticate via Clerk login"
    - "Authenticated user's email is checked against users table"
    - "Only users with email in users table can send commands"
    - "Commands are stored in Convex with userId"
    - "Commands are queryable via real-time subscription"
  artifacts:
    - path: "convex/users.ts"
      provides: "User authorization queries"
      exports: ["isAuthorized"]
    - path: "convex/commands.ts"
      provides: "Command mutations and queries"
      exports: ["sendCommand", "getLatestCommand", "acknowledgeCommand"]
    - path: "app/providers.tsx"
      provides: "Clerk and Convex context providers"
      contains: "ConvexProviderWithClerk"
    - path: "middleware.ts"
      provides: "Clerk auth middleware"
      contains: "clerkMiddleware"
  key_links:
    - from: "convex/commands.ts"
      to: "convex/users.ts"
      via: "isAuthorized check before mutation"
      pattern: "isAuthorized"
    - from: "app/providers.tsx"
      to: "Clerk + Convex"
      via: "ConvexProviderWithClerk"
      pattern: "ConvexProviderWithClerk"
    - from: "middleware.ts"
      to: "Clerk"
      via: "clerkMiddleware"
      pattern: "clerkMiddleware"
---

<objective>
Implement Clerk authentication, Convex functions for commands, and wire authorization so only users in the users table can send commands.

Purpose: Complete the backend foundation with working auth and command storage that Phase 2 (Web Controller) will consume.
Output: Clerk-protected app with Convex functions for sending/receiving commands and user authorization.
</objective>

<execution_context>
@/Users/tannersharon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tannersharon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-backend-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Clerk middleware and providers</name>
  <files>
    middleware.ts
    app/providers.tsx
    app/layout.tsx
    .env.local
  </files>
  <action>
    1. Create middleware.ts in project root for Clerk auth:
    ```typescript
    import { clerkMiddleware } from "@clerk/nextjs/server";

    export default clerkMiddleware();

    export const config = {
      matcher: [
        // Skip Next.js internals and static files
        "/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)",
        // Always run for API routes
        "/(api|trpc)(.*)",
      ],
    };
    ```

    2. Create app/providers.tsx with Clerk + Convex integration:
    ```typescript
    "use client";

    import { ClerkProvider, useAuth } from "@clerk/nextjs";
    import { ConvexProviderWithClerk } from "convex/react-clerk";
    import { ConvexReactClient } from "convex/react";
    import { ReactNode } from "react";

    const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

    export function Providers({ children }: { children: ReactNode }) {
      return (
        <ClerkProvider>
          <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
            {children}
          </ConvexProviderWithClerk>
        </ClerkProvider>
      );
    }
    ```

    3. Update app/layout.tsx to use providers:
    ```typescript
    import type { Metadata } from "next";
    import { Providers } from "./providers";
    import "./globals.css";

    export const metadata: Metadata = {
      title: "Pathoma Controller",
      description: "Remote video playback controller",
    };

    export default function RootLayout({
      children,
    }: {
      children: React.ReactNode;
    }) {
      return (
        <html lang="en">
          <body>
            <Providers>{children}</Providers>
          </body>
        </html>
      );
    }
    ```

    4. Ensure .env.local has Clerk keys (user must add these):
    - NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY
    - CLERK_SECRET_KEY
    - NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
    - NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up

    Note: If Clerk keys are missing, the app will fail to start. The checkpoint below verifies this.
  </action>
  <verify>
    - `npm run build` succeeds (may warn about missing env vars)
    - middleware.ts exists with clerkMiddleware export
    - app/providers.tsx exports Providers component
  </verify>
  <done>
    Clerk middleware and providers configured, ready for Convex auth integration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Convex functions for users and commands</name>
  <files>
    convex/users.ts
    convex/commands.ts
    convex/auth.config.ts
  </files>
  <action>
    1. Create convex/auth.config.ts for Clerk JWT verification:
    ```typescript
    export default {
      providers: [
        {
          domain: process.env.CLERK_JWT_ISSUER_DOMAIN,
          applicationID: "convex",
        },
      ],
    };
    ```
    Note: CLERK_JWT_ISSUER_DOMAIN will be set after user configures Clerk JWT template.

    2. Create convex/users.ts with authorization check:
    ```typescript
    import { query } from "./_generated/server";
    import { v } from "convex/values";

    // Check if a user's email is in the authorized users list
    export const isAuthorized = query({
      args: { email: v.string() },
      handler: async (ctx, args) => {
        const user = await ctx.db
          .query("users")
          .withIndex("by_email", (q) => q.eq("email", args.email))
          .unique();
        return user !== null;
      },
    });

    // Get user by email (for display purposes)
    export const getByEmail = query({
      args: { email: v.string() },
      handler: async (ctx, args) => {
        return await ctx.db
          .query("users")
          .withIndex("by_email", (q) => q.eq("email", args.email))
          .unique();
      },
    });
    ```

    3. Create convex/commands.ts with command CRUD:
    ```typescript
    import { mutation, query } from "./_generated/server";
    import { v } from "convex/values";

    // Send a command (requires authenticated user)
    export const send = mutation({
      args: {
        type: v.union(
          v.literal("play"),
          v.literal("pause"),
          v.literal("seekForward"),
          v.literal("seekBackward"),
          v.literal("speedUp"),
          v.literal("speedDown")
        ),
        amount: v.optional(v.number()),
      },
      handler: async (ctx, args) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) {
          throw new Error("Not authenticated");
        }

        // Check if user is authorized
        const email = identity.email;
        if (!email) {
          throw new Error("No email in identity");
        }

        const authorizedUser = await ctx.db
          .query("users")
          .withIndex("by_email", (q) => q.eq("email", email))
          .unique();

        if (!authorizedUser) {
          throw new Error("User not authorized");
        }

        // Create command
        const commandId = await ctx.db.insert("commands", {
          type: args.type,
          amount: args.amount,
          userId: identity.subject,
          createdAt: Date.now(),
          acknowledged: false,
        });

        return commandId;
      },
    });

    // Get latest unacknowledged command (for extension polling/subscription)
    export const getLatestUnacknowledged = query({
      handler: async (ctx) => {
        return await ctx.db
          .query("commands")
          .withIndex("by_createdAt")
          .filter((q) => q.eq(q.field("acknowledged"), false))
          .order("desc")
          .first();
      },
    });

    // Acknowledge a command (called by extension after execution)
    export const acknowledge = mutation({
      args: { commandId: v.id("commands") },
      handler: async (ctx, args) => {
        await ctx.db.patch(args.commandId, {
          acknowledged: true,
          acknowledgedAt: Date.now(),
        });
      },
    });

    // Get recent commands (for debugging/UI)
    export const getRecent = query({
      args: { limit: v.optional(v.number()) },
      handler: async (ctx, args) => {
        const limit = args.limit ?? 10;
        return await ctx.db
          .query("commands")
          .withIndex("by_createdAt")
          .order("desc")
          .take(limit);
      },
    });
    ```

    4. Run `npx convex dev --once` to push functions to Convex.
  </action>
  <verify>
    - `npx convex dev --once` succeeds
    - Convex dashboard shows users and commands functions
    - No TypeScript errors in convex/*.ts files
  </verify>
  <done>
    Convex functions deployed: user authorization check, command send/acknowledge/query.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete backend foundation with:
    - Next.js + Clerk + Convex integration
    - User authorization via email allowlist
    - Command storage with acknowledgment
    - Real-time query support
  </what-built>
  <how-to-verify>
    Prerequisites (user must complete):
    1. Add Clerk API keys to .env.local:
       - NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY
       - CLERK_SECRET_KEY
    2. Configure Clerk JWT template for Convex:
       - Clerk Dashboard -> JWT Templates -> New -> Convex
       - Copy Issuer URL to CLERK_JWT_ISSUER_DOMAIN in Convex environment

    Testing steps:
    1. Run `npm run dev` - should start without errors
    2. Run `npx convex dev` in another terminal
    3. Visit http://localhost:3000 - should show placeholder page
    4. In Convex dashboard, manually add a test user to `users` table:
       - email: (your Clerk login email)
       - createdAt: (current timestamp, e.g., Date.now())
    5. Open Convex dashboard Functions tab
    6. Test `users:isAuthorized` with your email - should return true
    7. Test `users:isAuthorized` with random email - should return false

    Expected results:
    - Dev server runs on http://localhost:3000
    - Convex dev shows "Synced" status
    - Authorization check works correctly
  </how-to-verify>
  <resume-signal>Type "approved" when backend is verified working, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run dev` + `npx convex dev` both run
2. Clerk middleware protects routes
3. Convex functions accessible in dashboard
4. isAuthorized correctly checks users table
5. send mutation creates commands with userId
</verification>

<success_criteria>
- AUTH-01: User can log in via Clerk (middleware + providers configured)
- AUTH-02: Only authorized emails can access controls (isAuthorized check in send mutation)
- AUTH-03: Admin can add emails in Convex dashboard (users table with email index)
- Commands stored in Convex with real-time subscription support (getLatestUnacknowledged query)
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-foundation/01-02-SUMMARY.md`
</output>
