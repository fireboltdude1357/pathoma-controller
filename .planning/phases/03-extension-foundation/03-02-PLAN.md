---
phase: 03-extension-foundation
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified: [extension/background.ts, extension/convex-client.ts, package.json]
autonomous: false

must_haves:
  truths:
    - "Service worker receives commands from Convex in real-time"
    - "Service worker reconnects automatically after termination"
    - "Auth state persists across service worker restarts"
  artifacts:
    - path: "extension/background.ts"
      provides: "Service worker with Convex subscription"
      contains: "getLatestUnacknowledged"
    - path: "extension/convex-client.ts"
      provides: "Convex client setup for service worker"
      contains: "ConvexClient"
  key_links:
    - from: "extension/background.ts"
      to: "convex/commands.ts"
      via: "Convex subscription"
      pattern: "api\\.commands\\.getLatestUnacknowledged"
    - from: "extension/background.ts"
      to: "chrome.storage"
      via: "State persistence"
      pattern: "chrome\\.storage\\.(local|session)"

user_setup:
  - service: convex
    why: "Extension needs Convex deployment URL"
    env_vars:
      - name: CONVEX_URL
        source: "Already configured in .env.local as NEXT_PUBLIC_CONVEX_URL"
    dashboard_config: []
---

<objective>
Wire service worker to Convex real-time subscription with reconnection and auth persistence.

Purpose: Enable extension to receive video control commands in real-time with resilient connection
Output: Service worker subscribed to Convex commands that survives restarts
</objective>

<execution_context>
@/Users/tannersharon/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tannersharon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-extension-foundation/03-01-SUMMARY.md
@convex/commands.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up esbuild for extension bundling</name>
  <files>package.json, extension/build.mjs</files>
  <action>
Install esbuild as dev dependency:
```bash
npm install -D esbuild
```

Create extension/build.mjs for bundling:
```javascript
import * as esbuild from 'esbuild';

await esbuild.build({
  entryPoints: ['extension/background.ts'],
  bundle: true,
  outfile: 'extension/dist/background.js',
  format: 'esm',
  target: 'es2020',
  platform: 'browser',
  // External chrome API (global in extension context)
  external: [],
  define: {
    'process.env.CONVEX_URL': JSON.stringify(process.env.NEXT_PUBLIC_CONVEX_URL || '')
  }
});

console.log('Extension built successfully');
```

Update package.json scripts:
```json
"build:extension": "node extension/build.mjs"
```

This replaces the tsc build with esbuild to bundle Convex client into the service worker.
  </action>
  <verify>
cat package.json | grep -q '"esbuild"' && echo "esbuild installed"
ls extension/build.mjs && echo "Build script exists"
  </verify>
  <done>
- esbuild installed
- build.mjs bundles extension with Convex client
- CONVEX_URL injected at build time
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Convex client wrapper for service worker</name>
  <files>extension/convex-client.ts</files>
  <action>
Create extension/convex-client.ts:

```typescript
import { ConvexClient } from 'convex/browser';
import { api } from '../convex/_generated/api';

// Convex URL injected at build time
declare const process: { env: { CONVEX_URL: string } };
const CONVEX_URL = process.env.CONVEX_URL;

let client: ConvexClient | null = null;

export function getConvexClient(): ConvexClient {
  if (!client) {
    if (!CONVEX_URL) {
      throw new Error('CONVEX_URL not configured');
    }
    client = new ConvexClient(CONVEX_URL);
  }
  return client;
}

export function subscribeToCommands(
  onCommand: (command: any) => void
): () => void {
  const convex = getConvexClient();

  // Subscribe to latest unacknowledged command
  const unsubscribe = convex.onUpdate(
    api.commands.getLatestUnacknowledged,
    {},
    (command) => {
      if (command) {
        console.log('[Pathoma Controller] Command received:', command);
        onCommand(command);
      }
    }
  );

  return unsubscribe;
}

export { api };
```

This module wraps Convex client creation and subscription for use in the service worker.
  </action>
  <verify>
cat extension/convex-client.ts | grep -q "ConvexClient" && echo "Convex client wrapper OK"
cat extension/convex-client.ts | grep -q "subscribeToCommands" && echo "Subscription helper OK"
  </verify>
  <done>
- convex-client.ts provides getConvexClient() and subscribeToCommands()
- Convex URL read from build-time injection
- Subscription wrapper handles command updates
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement service worker with subscription and reconnection</name>
  <files>extension/background.ts</files>
  <action>
Replace extension/background.ts with full implementation:

```typescript
import { subscribeToCommands, getConvexClient, api } from './convex-client';

console.log('[Pathoma Controller] Service worker starting');

// State management via chrome.storage for persistence across restarts
interface ExtensionState {
  lastCommandId: string | null;
  connected: boolean;
}

async function getState(): Promise<ExtensionState> {
  const result = await chrome.storage.local.get(['lastCommandId', 'connected']);
  return {
    lastCommandId: result.lastCommandId ?? null,
    connected: result.connected ?? false,
  };
}

async function setState(updates: Partial<ExtensionState>): Promise<void> {
  await chrome.storage.local.set(updates);
}

// Track subscription for cleanup
let unsubscribe: (() => void) | null = null;

async function startSubscription(): Promise<void> {
  // Clean up existing subscription
  if (unsubscribe) {
    unsubscribe();
    unsubscribe = null;
  }

  const state = await getState();
  console.log('[Pathoma Controller] Starting subscription, last command:', state.lastCommandId);

  unsubscribe = subscribeToCommands(async (command) => {
    // Skip if we've already processed this command
    if (command._id === state.lastCommandId) {
      console.log('[Pathoma Controller] Skipping already processed command');
      return;
    }

    console.log('[Pathoma Controller] New command:', command.type, command.amount);

    // Store the command ID to prevent re-processing after restart
    await setState({ lastCommandId: command._id });

    // TODO (Phase 4): Forward command to content script for execution
    // For now, just log that we received it
    console.log('[Pathoma Controller] Command queued for execution');
  });

  await setState({ connected: true });
  console.log('[Pathoma Controller] Subscription active');
}

// Service worker lifecycle
self.addEventListener('install', () => {
  console.log('[Pathoma Controller] Service worker installed');
});

self.addEventListener('activate', () => {
  console.log('[Pathoma Controller] Service worker activated');
  // Start subscription on activate
  startSubscription().catch(err => {
    console.error('[Pathoma Controller] Failed to start subscription:', err);
  });
});

// Handle service worker wakeup (e.g., from chrome.storage changes, alarms, etc.)
// The subscription will automatically reconnect when the client is used
chrome.storage.onChanged.addListener((changes, area) => {
  if (area === 'local') {
    console.log('[Pathoma Controller] Storage changed:', Object.keys(changes));
  }
});

// Keep-alive: Use chrome.alarms to periodically wake the service worker
// This ensures the Convex WebSocket stays connected
chrome.alarms.create('keepalive', { periodInMinutes: 0.5 }); // Every 30 seconds

chrome.alarms.onAlarm.addListener((alarm) => {
  if (alarm.name === 'keepalive') {
    // Check if subscription is active, restart if needed
    if (!unsubscribe) {
      console.log('[Pathoma Controller] Restarting subscription after alarm');
      startSubscription().catch(console.error);
    }
  }
});

// Start subscription immediately on load
startSubscription().catch(console.error);

export {};
```

Key features:
1. Uses chrome.storage.local for state persistence across service worker restarts
2. Tracks lastCommandId to prevent duplicate command processing
3. Uses chrome.alarms for keep-alive to maintain WebSocket connection
4. Automatically restarts subscription on service worker wakeup
  </action>
  <verify>
cat extension/background.ts | grep -q "subscribeToCommands" && echo "Subscription wired"
cat extension/background.ts | grep -q "chrome.storage" && echo "Storage persistence"
cat extension/background.ts | grep -q "chrome.alarms" && echo "Keep-alive alarm"
  </verify>
  <done>
- Service worker subscribes to Convex commands
- chrome.storage.local persists lastCommandId across restarts
- chrome.alarms provides keep-alive for WebSocket
- Subscription auto-restarts on alarm
  </done>
</task>

<task type="auto">
  <name>Task 4: Update manifest and build extension</name>
  <files>extension/manifest.json</files>
  <action>
Update extension/manifest.json to add alarms permission:
```json
"permissions": ["storage", "alarms"]
```

Build the extension with Convex URL from .env.local:
```bash
source .env.local && npm run build:extension
```

The build will bundle Convex client and inject the URL.
  </action>
  <verify>
cat extension/manifest.json | grep -q '"alarms"' && echo "Alarms permission added"
source .env.local && npm run build:extension && ls extension/dist/background.js && echo "Build successful"
  </verify>
  <done>
- manifest.json has storage and alarms permissions
- Extension builds successfully with bundled Convex client
- background.js ready for loading in Chrome
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Chrome extension with Convex real-time subscription that:
- Connects to Convex and subscribes to getLatestUnacknowledged
- Persists state in chrome.storage.local
- Uses alarms for keep-alive to survive service worker termination
  </what-built>
  <how-to-verify>
1. Load extension in Chrome:
   - Go to chrome://extensions
   - Enable "Developer mode" (toggle in top right)
   - Click "Load unpacked"
   - Select the `extension` folder (not `extension/dist`)
   - Note: The manifest.json in extension/ points to dist/background.js

2. Check service worker is running:
   - Click "Service Worker" link on the extension card
   - Verify logs show "Service worker starting", "installed", "activated"
   - Look for "Subscription active" message

3. Test command receipt:
   - Open http://localhost:3000 in another tab
   - Sign in if needed
   - Click a command button (e.g., Play)
   - Check service worker console for "Command received" and "Command queued"

4. Test reconnection:
   - In chrome://extensions, click the reload icon on the extension
   - Watch service worker logs - should show "Restarting subscription after alarm"
   - Send another command - should still be received

5. Verify lastCommandId persistence:
   - In service worker devtools, run: chrome.storage.local.get(console.log)
   - Should show lastCommandId matching the command you sent
  </how-to-verify>
  <resume-signal>Type "approved" if extension receives commands in real-time, or describe issues</resume-signal>
</task>

</tasks>

<verification>
After all tasks and checkpoint:
1. Extension loads without errors
2. Service worker starts and connects to Convex
3. Commands sent from web app appear in service worker console
4. Extension survives reload and reconnects automatically
5. lastCommandId persists in chrome.storage.local
</verification>

<success_criteria>
- EXT-01: Extension targets pcloud.link (via host_permissions)
- EXT-02: Service worker subscribes to commands via Convex real-time
- CONN-02: Extension auto-reconnects via alarms keep-alive
- Auth state (lastCommandId) persists via chrome.storage.local
</success_criteria>

<output>
After completion, create `.planning/phases/03-extension-foundation/03-02-SUMMARY.md`
</output>
